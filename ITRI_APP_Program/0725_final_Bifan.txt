#include "ITRI_APP.h"

#define WHEEL_LEFT	0
#define WHEEL_RIGHT	1
#define MODE_MANUAL	0
#define MODE_AUTO	1
#define MODE_NUMBER_INDEX_ONE				1
#define MODE_NUMBER_INDEX_TWO				2
#define MODE_NUMBER_INDEX_THREE				3
#define POLE_NUMBER		  		  			30
#define CIRCLE_DIAMETER						84.82
#define AXEL_LENGTH							48.8 // [cm]

#define PRINT_ADC

#define RIGHT_WHEEL_KP 30.0
#define RIGHT_WHEEL_KI 0.0
#define RIGHT_WHEEL_KD 3.0

#define LEFT_WHEEL_KP 30.0
#define LEFT_WHEEL_KI 0.0
#define LEFT_WHEEL_KD 3.0

#define LOW_PASS_VALUE   0.006
#define LOW_PASS_MEANVALUE   0.0006
#define MAXIMUM_RPM		50
int ADVALUE_THROTTLE_MIDDLE 	= 1027;
int ADVALUE_THROTTLE_THRESHOLD 	= 10;
double ADVALUE_THROTTLE_SCALE 	= -0.2; 
int ADVALUE_STEERING_MIDDLE  	= 1017;
int ADVALUE_STEERING_THRESHOLD 	= 10;
int ADVALUE_STEERING_RANGE 	 	= 7500; 

double m_dWheelPeriperal = 81.68;

CITRICar ITRICar;
int car;
double dSpeedCmd;


////////////////////////////////////////////////
void ResetWheel(HubMotorWheel* pWheel)
{
	pWheel->m_dTotalMileage = 0;
	pWheel->m_dMeterPerStep = 1. / (3 * POLE_NUMBER) * CIRCLE_DIAMETER;
	pWheel->m_motor.nPoleNumber = POLE_NUMBER;
    pWheel->m_drive.m_dRPMLowpass = 0;
    pWheel->m_drive.m_dRPMInstantaneous = 0;
}

void WheelControl(HubMotorWheel* pWheel, double dSpeedLinear, double dSpeedRotate)
{
	double dSpeedCmd = pWheel->m_drive.m_nMotorForwardDirection * 
		(dSpeedLinear - pWheel->m_drive.m_nMotorForwardDirection * dSpeedRotate);
	dSpeedCmd = _fmin(MAXIMUM_RPM, _fmax(-MAXIMUM_RPM, dSpeedCmd));
	GetLowpassDirectionalSpeed(&pWheel->m_drive);
	MotorSetDirectionAndDuty(&pWheel->m_drive, 
		PIDFeedback(&pWheel->m_drive.m_ctrl, dSpeedCmd, pWheel->m_drive.m_dRPMLowpass));
}

/////////////////////////////

void InitPIDControllers()
{
	for (int i = 0; i < HUB_MOTORS; i++)
		InitPIDController(&ITRICar.m_wheel[i].m_drive.m_ctrl);
}

void ResetMotorOutput()
{
	for (int i = 0; i < 2; i++)
		ResetOutput(&ITRICar.m_wheel[i].m_drive);
}

void MotorSpeedControl(uint64_t nFastLoopCount)
{
	for (int i = 1; i >= 0; i--)
	{
		car = i;
		WheelControl(&ITRICar.m_wheel[i],
			ITRICar.m_dSpeedThrottle * (1 - _fabs(ITRICar.m_dRotateRatio)), ITRICar.m_dSpeedThrottle * ITRICar.m_dRotateRatio);
		/*if (nFastLoopCount % 5000 == 0 &&
			ITRICar.m_wheel[i].m_drive.m_dRPMLowpass < 1 && 
			ITRICar.m_wheel[i].m_drive.m_bCommandForward)
		{
			ITRICar.m_wheel[i].m_drive.m_bCommandForward = false;
			StepChangeDetected(&ITRICar.m_wheel[i].m_drive);
			CBLDCMotorDrive *pDrive = &ITRICar.m_wheel[i].m_drive;
			BLDC6StepControl(pDrive->m_duty.m_TIM, 
			(pDrive->m_nBLDCStep[CURRENT_STATE] + 1 > 6) ? 1 : pDrive->m_nBLDCStep[CURRENT_STATE] + 1, 
			pDrive->m_nPWMMode,
			pDrive->m_nPWMTimerPeriod, pDrive->m_bCommandForward);
		}*/
	}
}
void ReadDIOControl()
{
	ITRICar.m_nWorkMode[CURRENT_STATE] = GPIO_ReadInputDataBit(GPIOE, GPIO_Pin_2);
	ITRICar.m_nWorkMode[CURRENT_STATE] = MODE_AUTO;
	if (ITRICar.m_nWorkMode[PREVIOUS_STATE] != ITRICar.m_nWorkMode[CURRENT_STATE])
		InitPIDControllers();
}

void ControlPinInit(GPortPinArray ppa)
{
	ITRICar.m_ppaControl = ppa;
	NuEnableInputPPA(ppa); 
	ReadDIOControl();
}

void ReadHandleThreeMode(void)
{
	for (int i = 0; i < ITRICar.m_ppaControl.m_nPins; i++)
		ITRICar.nReadModeNumberPin[i] = NuGetBit(ITRICar.m_ppaControl.m_gpp[i]);
}

////////////////////////////////////////
int AD_VALUE_SIZE	= ADC_CHANNELS * 20;

void CarPWMDisablePinInit(GPortPin gpp)
{
	PortPin pp = PP(gpp);
	ITRICar.m_pwmDisable = gpp;
	NuEnableOutputPP(gpp);
	GPIO_SetBits(pp.m_typedef, pp.m_GPIO);
}

uint32_t time = 0;
uint16_t sec = 0;
void ITRICarInit(bool bUseSteering, DWORD nPWMMode, int nPWMHz)
{
	mgrPWM.m_nHzSignal = nPWMHz;
	mgrPWM.m_nModePWM = nPWMMode;
	mgrPWM.m_nCallFunction = PWM_CALL_HALF_BLDC;
	ITRICar.m_bUseSteering = bUseSteering;	
	ITRICar.m_dSpeedThrottle = 0;
	ITRICar.m_dRotateRatio = 0;
	ITRICar.m_nWorkMode[CURRENT_STATE] = ITRICar.m_nWorkMode[PREVIOUS_STATE] = MODE_MANUAL;
	for (int i = 0; i < ADC_CHANNELS; i++)
	{
		ResetWheel(&ITRICar.m_wheel[i]);
	}
	ITRICar.m_dLPFValue[ADC_THROTTLE] = 
		ITRICar.m_dLPFValueMean[ADC_THROTTLE] = ADVALUE_THROTTLE_MIDDLE;
	ITRICar.m_dLPFValue[ADC_STEERING] = 
		ITRICar.m_dLPFValueMean[ADC_STEERING] = ADVALUE_STEERING_MIDDLE;
	ControlPinInit((GPortPinArray) {1, E2});//ControlPinInit((GPortPinArray) {3, E2, E3, E4});
	NuOPModeEnableADC(ST_nCH_1ADC, 43750, -AD_VALUE_SIZE, (GPortPinArray) {3, A1, A2, A3});
	ITRICar.m_wheel[WHEEL_LEFT].m_drive.m_bInitStart = false;
	ITRICar.m_wheel[WHEEL_RIGHT].m_drive.m_bInitStart = false;
	CarPWMDisablePinInit(B2);
	CarPWMDisablePinInit(C0);
	GPIO_WriteBit(GPIOB, GPIO_Pin_2, Bit_RESET);
	GPIO_WriteBit(GPIOC, GPIO_Pin_0, Bit_RESET);
	BLDCMotorInit(&ITRICar.m_wheel[WHEEL_LEFT].m_drive, 1,
		true, nPWMMode,
		(GPortPinArray) {3, E8, E10, E12},  
		B3, 
		(PWMModule) {ST_TIMER_1, nPWMHz, (GPortPinArray) {7, A8, E11, A10, B12, A7, B14, B15}}, none,
		(PIDController) {LEFT_WHEEL_KP, LEFT_WHEEL_KI, LEFT_WHEEL_KD, 50});		
		
	BLDCMotorInit(&ITRICar.m_wheel[WHEEL_RIGHT].m_drive, 2,
		false, nPWMMode,
		(GPortPinArray) {3, E7, E9, E15},
		B4, 
		(PWMModule) {ST_TIMER_8, nPWMHz, (GPortPinArray) {7, C6, C7, C8, A6, A5, B0, B1}}, none,		// KP KI KD
		(PIDController) {RIGHT_WHEEL_KP, RIGHT_WHEEL_KI, RIGHT_WHEEL_KD, 50});

	ITRICar.m_nPIDFastLoopSkip = FASTLOOP_HZ / ITRICar.m_wheel[WHEEL_LEFT].m_drive.m_ctrl.m_nHzPID;
}
int nCntWrite = 0;
void ITRICarReportWrite(bool bReadWrite)
{
	char szText[MAX_JSON_VALUE];
	NuTimeReport(szText);
	nCntWrite++;
	if (nCntWrite % 20 != 0)
		return;
	fprintf(USART_FILE, 
		ITRICar.m_nWorkMode[CURRENT_STATE] == bReadWrite? "{\"SetBeepValues\"=\"%s,%d,%d,%.2f,%.2f,%.2f,%.2f\"}":"{\"SetValues\"=\"%s,%d,%d,%.2f,%.2f,%.2f,%.2f\"}",
		szText,
		ITRICar.m_wheel[WHEEL_LEFT].m_drive.m_nStepCount[CURRENT_STATE],
		ITRICar.m_wheel[WHEEL_RIGHT].m_drive.m_nStepCount[CURRENT_STATE],
		ITRICar.m_dLPFValue[ADC_THROTTLE],
		ITRICar.m_dLPFValue[ADC_STEERING],
		ITRICar.m_dLPFValueMean[ADC_THROTTLE],
		ITRICar.m_dLPFValueMean[ADC_STEERING]);
}

void ReadAIOControl()
{
	if (ITRICar.m_nWorkMode[CURRENT_STATE] != MODE_AUTO) 
	{
		ITRICarReportWrite(true);
		return;
	}
	for (int j = 0; j < ADC_CHANNELS; j++)
	{
		for (int i = j; i < AD_VALUE_SIZE; i += ADC_CHANNELS)
		{
			ITRICar.m_dLPFValue[j] += (mgrADC.m_dmaMemory0Base[0][i] - ITRICar.m_dLPFValue[j]) * LOW_PASS_VALUE;
		}
	}
	ITRICar.m_dSpeedThrottle = fabs(ITRICar.m_dLPFValue[ADC_THROTTLE] - ADVALUE_THROTTLE_MIDDLE) > ADVALUE_THROTTLE_THRESHOLD?
		(ITRICar.m_dLPFValue[ADC_THROTTLE] - ADVALUE_THROTTLE_MIDDLE) * ADVALUE_THROTTLE_SCALE: 0;	
	ITRICar.m_dRotateRatio = fabs(ITRICar.m_dLPFValue[ADC_STEERING] - ADVALUE_STEERING_MIDDLE) > ADVALUE_STEERING_THRESHOLD?
		(ITRICar.m_dLPFValue[ADC_STEERING] - ADVALUE_STEERING_MIDDLE) / ADVALUE_STEERING_RANGE: 0;	
	//ITRICar.m_dSpeedThrottle = 25.0;
	//ITRICar.m_dRotateRatio = 0.0;
	ITRICarReportWrite(false);
}

bool MotorBrake(bool bStop)
{
	if (bStop)
		ResetMotorOutput();
	return bStop;
}

///////////////////////////////////////////////
void ITRICarMain(void)
{
	ITRICarInit(true /*use steering*/, MODE_BISYNC, 20000 /*Hz*/); 
	ResetMotorOutput();
	JsonWriteIntoJsonPair("ITRICar", "ON"); 
}


void ITRICarReport(void)
{
	if (!m_bSystemReportInited)
	{
		fprintf(USART_FILE, "{\"OpenCSVFile\" = \"D:/test123.csv\"}"); 
		fprintf(USART_FILE, "{\"SetKeys\" = \"Time,Left Wheel,Right Wheel,Throttle,Steering,Thr_Middle,St_Middle\"}"); 
		m_bSystemReportInited = true;
	}
}

void MotorCalculateMileage(HubMotorWheel* pWheel)
{
	pWheel->m_dTotalMileage = pWheel->m_dMeterPerStep * pWheel->m_drive.m_nStepCount[CURRENT_STATE];
}

void ITRICarNormalLoop(void)
{ 
	ReadDIOControl();
	if (!MotorBrake(ITRICar.m_nWorkMode[CURRENT_STATE] == MODE_MANUAL))
		ReadAIOControl();
	for (int i = 0; i < 2; i++)
		MotorCalculateMileage(&ITRICar.m_wheel[i]);
	ITRICar.m_nWorkMode[PREVIOUS_STATE] = ITRICar.m_nWorkMode[CURRENT_STATE];
}

void ITRICarFastLoop(uint64_t nFastLoopCount)
{
	for (int i = 1; i >= 0; i--)
	{
		GetHallSensorState(&ITRICar.m_wheel[i].m_drive);
		if (ITRICar.m_wheel[i].m_drive.m_nStepChangeCountDown >= 0)
		{
			if (ITRICar.m_wheel[i].m_drive.m_nStepChangeCountDown == 0)
				DoChangeStepControl(&ITRICar.m_wheel[i].m_drive);
			ITRICar.m_wheel[i].m_drive.m_nStepChangeCountDown--;
		}
	}
	if (ITRICar.m_nWorkMode[CURRENT_STATE] == MODE_AUTO &&
			nFastLoopCount % ITRICar.m_nPIDFastLoopSkip == 0)
		MotorSpeedControl(nFastLoopCount); 
}

void JITRIApp(DWORD param[])
{
	char szText[MAX_JSON_VALUE];
	JsonPartition(param, szText);
	ITRICar.m_dLPFValueMean[ADC_THROTTLE] = Bound(5000, 1000, Getint32(szText, ","));
	ITRICar.m_dLPFValueMean[ADC_STEERING] = Bound(5000, 1000, Getint32(szText, ","));
	m_bSystemReportInited = false;
}
